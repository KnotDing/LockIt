name: Build and Release macOS App

on:
  push:
    branches:
      - main
    tags:
      - 'v*' # Trigger on tags like v1.0.0

jobs:
  build-and-release:
    runs-on: macos-latest
    permissions:
      contents: write # Grant write permission for GITHUB_TOKEN to create releases

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Xcode version
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.2.0'

    - name: Get App Version and Release Tag
      id: get_version
      run: |
        VERSION=$(/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" LockIt/Info.plist)
        BUILD_NUMBER=$(/usr/libexec/PlistBuddy -c "Print CFBundleVersion" LockIt/Info.plist)
        echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
        echo "APP_BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV

        # Extract tag name if triggered by a tag push
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          RELEASE_VERSION=$(echo "${{ github.ref }}" | sed -e "s/refs\/tags\///g")
        else
          RELEASE_VERSION="v$VERSION" # Fallback to Info.plist version if not a tag
        fi
        echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_ENV

    - name: Import Certificate
      env:
        SIGNING_CERTIFICATE_BASE64: ${{ secrets.SIGNING_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
      run: |
        # Create a temporary keychain
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        KEYCHAIN_PASSWORD=github-actions
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security default-keychain -s "$KEYCHAIN_PATH"

        # Decode and import the certificate
        CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
        echo -n "$SIGNING_CERTIFICATE_BASE64" | base64 --decode -o "$CERTIFICATE_PATH"
        echo "Password length: ${#P12_PASSWORD}"
        shasum -a 256 "$CERTIFICATE_PATH"
        echo "Importing certificate..."
        security import "$CERTIFICATE_PATH" -k "$KEYCHAIN_PATH" -P "$P12_PASSWORD" -A
        if [ $? -ne 0 ]; then
          echo "Certificate import failed."
          exit 1
        fi
        
        echo "Setting key partition list..."
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        if [ $? -ne 0 ]; then
          echo "Setting key partition list failed."
          # This might not be a fatal error, so we can choose to continue
        fi

        # Add the keychain to the search list
        security list-keychains -d user -s "$KEYCHAIN_PATH"

        # Find the code signing identity
        echo "Looking for code signing identity..."
        security find-identity -v -p codesigning "$KEYCHAIN_PATH"
        CODE_SIGN_IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | head -n 1 | grep -o '".*"' | tr -d '"')

        if [ -z "$CODE_SIGN_IDENTITY" ]; then
          echo "Code signing identity not found!"
          exit 1
        fi
        echo "Found identity: $CODE_SIGN_IDENTITY"
        echo "CODE_SIGN_IDENTITY=${CODE_SIGN_IDENTITY}" >> $GITHUB_ENV

        # Clean up
        rm "$CERTIFICATE_PATH"

    - name: Build Application
      run: |
        APP_NAME="LockIt"
        
        xcodebuild clean build \
          -workspace LockIt.xcodeproj/project.xcworkspace \
          -scheme LockIt \
          -configuration Release \
          -destination "platform=macOS" \
          -derivedDataPath build \
          "CODE_SIGN_IDENTITY=${{ env.CODE_SIGN_IDENTITY }}"

    - name: Create DMG
      run: |
        APP_NAME="LockIt"
        APP_BUNDLE_PATH="build/Build/Products/Release/${APP_NAME}.app"
        DMG_NAME="${APP_NAME}-${{ env.RELEASE_VERSION }}.dmg"
        TEMP_DMG_NAME="${DMG_NAME}.temp.dmg"
        
        echo "Creating DMG for: $APP_BUNDLE_PATH"
        echo "Output DMG: $DMG_NAME"

        # Create a new blank disk image
        hdiutil create -ov -fs HFS+ -volname "${APP_NAME}" -size 100m "${TEMP_DMG_NAME}"

        # Mount the disk image
        hdiutil attach "${TEMP_DMG_NAME}" -mountpoint "/Volumes/${APP_NAME}"

        # Copy the application into the disk image
        cp -R "${APP_BUNDLE_PATH}" "/Volumes/${APP_NAME}/"

        # Create a symlink to the Applications folder
        ln -s /Applications "/Volumes/${APP_NAME}/Applications"

        # Unmount the disk image
        hdiutil detach "/Volumes/${APP_NAME}"

        # Convert the disk image to a compressed, read-only format
        hdiutil convert "${TEMP_DMG_NAME}" -format UDBZ -o "${DMG_NAME}"

        # Remove the temporary disk image
        rm "${TEMP_DMG_NAME}"

    - name: Create GitHub Release
      if: startsWith(github.ref, 'refs/tags/v') # Only create release on tag pushes
      uses: softprops/action-gh-release@v1
      with:
        files: LockIt-${{ env.RELEASE_VERSION }}.dmg
        name: Release ${{ env.RELEASE_VERSION }}
        tag_name: ${{ github.ref }}
        body: |
          # LockIt ${{ env.RELEASE_VERSION }}

          This is an automated release.
          
          ## Changes
          (Add release notes here)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
